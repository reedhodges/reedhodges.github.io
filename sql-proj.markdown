---
layout: page
title: SQL and Python basketball stats project
permalink: /sql-project/
---

Recently I wanted to learn how to run SQL queries.  In deciding which data to use, I wanted a dataset where I'd have some level of intuition for what the data points mean.  An obvious choice is sports statistics, and basketball is the sport with which I'm most familiar.  

I decided this also would be a good opportunity to further practice my python skills, particularly in object-oriented programming. I wrote a program that would simulate a basketball season in an imaginary league with 30 teams, each playing every other team twice.  It would store the box score for each game in a csv file, which I could then store in an SQL database and run queries against.

## <ins>Dataset</ins>

I want the simulated basketball games to be as close to reality as possible, so let's look into typical game statistics using a Kaggle dataset of real NBA games.  The dataset has 5 csv files: teams, players, games, games_details, and ranking.  They all contain multiple columns of data, for example:

- teams.csv: founding year, mascot, arena name, owner name, etc.
- players.csv: player name, player ID, etc.
- games.csv: game date, team IDs, stats for each team, etc.
- games_details.csv: box scores for each game
- ranking.csv: team records for each season

My simulated basketball league will assign to a player expected values for several of their in-game statistics, e.g. three-point field goal percentage and number of rebounds.  Let's look at the career three-point field goal percentages for starting players, and plot the distribution for each of the three positions, guard (`G`), forward, (`F`), and center (`C`).  It is quick to run an SQL query against the games_details table to get this data:

```sql
SELECT PLAYER_ID, SUM(FG3M) AS Total_FG3M, SUM(FG3A) AS Total_FG3A
FROM games_details
WHERE START_POSITION = 'G'
GROUP BY PLAYER_ID;
```

This query groups the starting guards by their ID, and sums the values in the columns `FG3M` and `FG3A`, returning the sums along with their ID.  Only the starting players have a non-null value for `START_POSITION`, so the `WHERE START_POSITION = 'G'` line selects only the starting guards.  We can do an analogous query for two-point field goals, and we can then export the data to do some exploratory data analysis in Python.

## <ins>Exploratory data analysis</ins>

We can use `pandas` to manipulate the data generated by our SQL query.  A processing function can filter out outliers.

```python
import pandas as pd

def read_and_process_data(file_path, position, filter_col, filter_value, percent_col, numerator, denominator):
    df = pd.read_csv(file_path)
    # remove rows with 0 attempts
    df = df[df[filter_col] != filter_value]
    # add column for FG% or FG3%
    df[percent_col] = df[numerator] / df[denominator]
    # exclude outliers of 0% and 100%
    df = df[df[percent_col].between(0.01, 0.99)]  
    # add column for position
    df['Position'] = position
    return df
```

After processing the files, we generate histograms with the `plotly` library.

```python
import plotly.express as px

# Histograms
fg2_fig = px.histogram(fg2_data, x='FG2%', color='Position', marginal='rug', opacity=0.7, nbins=100, barmode='group')
fg3_fig = px.histogram(fg3_data, x='FG3%', color='Position', marginal='rug', opacity=0.7, nbins=100, barmode='group')
```

Click on the histograms to be redirected to an interactive version where you can select/deselect different positions.

[<img src="https://raw.githubusercontent.com/reedhodges/bball_league/main/images/fg2_fig.png" alt="FG2% plot" style="border: 2px solid  gray;">](https://raw.githubusercontent.com/reedhodges/bball_league/main/html_files/fg2_fig.html)

[<img src="https://raw.githubusercontent.com/reedhodges/bball_league/main/images/fg3_fig.png" alt="FG3% plot" style="border: 2px solid  gray;">](https://raw.githubusercontent.com/reedhodges/bball_league/main/html_files/fg3_fig.html)

It is reasonable to say these follow a normal distribution.  The means and standard deviations are:

```
FG2%
G: mean = 0.47, std = 0.09
F: mean = 0.49, std = 0.10
C: mean = 0.53, std = 0.10
FG3%
G: mean = 0.35, std = 0.09
F: mean = 0.34, std = 0.09
C: mean = 0.32, std = 0.12
```

We can use these values in our simulation when generating a player.

The rebounds and assists, on the other hand, appear to follow a Poisson distribution. This makes sense, because it is reasonable to approximate that these events (i.e. rebound or assist) occur at a constant mean rate and independently of the time since the last event.

[<img src="https://raw.githubusercontent.com/reedhodges/bball_league/main/images/fig_reb.png" alt="Reb plot" style="border: 2px solid  gray;">](https://raw.githubusercontent.com/reedhodges/bball_league/main/html_files/fig_reb.html)

[<img src="https://raw.githubusercontent.com/reedhodges/bball_league/main/images/fig_ast.png" alt="Ast plot" style="border: 2px solid gray;">](https://raw.githubusercontent.com/reedhodges/bball_league/main/html_files/fig_ast.html)


The means for these distributions are:

```
G: 3.8 reb, 4.6 ast
F: 6.2 reb, 2.3 ast
C: 8.1 reb, 1.6 ast
```

We are now ready to write the code for our simulated league.

## <ins>Python simulation</ins>

The python libraries used are as follows:

```python
import numpy as np
import pandas as pd
import random
from itertools import combinations
from math import comb
```

### Creating the rosters

I create a class for each of the three basic positions, using the means and standard deviations (if applicable) for the distributions we investigated earlier.  For example, the `guard` class looks like:

```python
class guard(player):
    def __init__(self, seed=None):
        super().__init__({
            # stat: (mean, std)
            'fg2': (0.47, 0.09),
            'fg3': (0.35, 0.09),
            # mean value 
            'reb': 3.8,
            'ast': 4.6
        }, seed=seed)
```

I then have a `player` class that, when called, generates a player of a particular position and gives them fixed expected values for their stats, by picking a number either according to a normal or Poisson distribution.  This makes each player have some level of uniqueness to them.

```python
class player:
    def __init__(self, typical_stats, seed=None):
        # initialize dictionary for expected stats
        self.expected_stats = {}
        # set random seed
        self.seed = seed
        # make a dictionary of means and stds
        means_stds = {key: value for key, value in typical_stats.items() if type(value) == tuple} 
        # make a dictionary of Poisson distributed stats
        poissons = {key: value for key, value in typical_stats.items() if type(value) == float}
        # pick random values from normal distribution for shooting percentages
        for stat, (mean, std) in means_stds.items():
            self.expected_stats[stat] = np.random.normal(mean, std, 1)[0]
        # pick random values from Poisson distribution for other stats
        for stat, mean in poissons.items():
            self.expected_stats[stat] = np.random.poisson(mean, 1)[0]
        # create an overall rating of each player based on their expected stats
        self.overall = (self.expected_stats['fg2'] + self.expected_stats['fg3']  + self.expected_stats['reb'] + self.expected_stats['ast']) / (typical_stats['fg2'][0] * typical_stats['fg3'][0] * typical_stats['reb'] * typical_stats['ast']) 
```

The `team` class initializes a team with a particular name, and generates five players to be on the roster.

```python
class team:
    def __init__(self, name, seed=None):
        self.name = name
        self.seed = seed
        # roster
        self.pg = guard(seed=self.seed)
        self.sg = guard(seed=self.seed + 1)
        self.sf = forward(seed=self.seed)
        self.pf = forward(seed=self.seed + 1)
        self.c = center(seed=self.seed)
```

This class also has dictionaries that contain the expected distribution of stats by position, which are weighted according to the player's expected values for those stats.  For example, for rebounds we have:

```python
class team:
...
        # expected distribution of rebounds by position
        self.reb_distribution_pos = {
            'PG': self.pg.expected_stats['reb'] / self.expected_reb,
            'SG': self.sg.expected_stats['reb'] / self.expected_reb,
            'SF': self.sf.expected_stats['reb'] / self.expected_reb,
            'PF': self.pf.expected_stats['reb'] / self.expected_reb,
            'C': self.c.expected_stats['reb'] / self.expected_reb
        }
...
        # pace of team: average number of possessions per game
        self.pace = np.random.normal(75, 5, 1)[0]
```

The last line sets a pace for the team, which will be used later so that each simulated game does not have the same number of possessions.

### Simulating a game

The program works by simulating a bunch of individual possessions in a game between two teams.  This is done by the `possession` function.  It goes through several steps:

- initialize the stats for each player on that possession
- decide whether a turnover occurs (5% chance)
- if no turnover, decide which player will take the shot
- decide whether the shot is made using the expected field goal percentage established in the appropriate instance of the `player` class
- if the shot is made, record it, and allow for the chance for a player to get an assist
- if the shot is missed, allow for a chance of an offensive rebound
- if no offensive rebound, pick a defending player to get the rebound, record it
- return the final player stats for the possession

The code is below.

```python
def possession(off_team, def_team):
    # initialize who will have the ball on the next possession
    next_team = def_team
    # initialize stats for this possession
    off_possession_result = {
        # [PTS, REB, AST, 2PM, 2PA, 3PM, 3PA]
        'PG': [0, 0, 0, 0, 0, 0, 0],
        'SG': [0, 0, 0, 0, 0, 0, 0],
        'SF': [0, 0, 0, 0, 0, 0, 0],
        'PF': [0, 0, 0, 0, 0, 0, 0],
        'C': [0, 0, 0, 0, 0, 0, 0]
    }
    def_possession_result = {
        # [PTS, REB, AST, 2PM, 2PA, 3PM, 3PA]
        'PG': [0, 0, 0, 0, 0, 0, 0],
        'SG': [0, 0, 0, 0, 0, 0, 0],
        'SF': [0, 0, 0, 0, 0, 0, 0],
        'PF': [0, 0, 0, 0, 0, 0, 0],
        'C': [0, 0, 0, 0, 0, 0, 0]
    }
    # team will turn over the ball 5% of the time
    random_turnover = random.random()
    if random_turnover < 0.05:
        return off_possession_result, def_possession_result, next_team
    # pick a player to take the shot according to the team's distribution
    random_player = weighted_random_key(off_team.shot_distribution_pos)
    # split the string random_player into the position and shot worth
    position, shot_worth = random_player.split('_')
    shot_worth = int(shot_worth)
    # add the shot to the attempts
    if shot_worth == 2:
        off_possession_result[position][4] += 1
        # get the shot chance for the shot
        shot_chance = off_team.positions_dict[position].expected_stats['fg2']
    else:
        off_possession_result[position][6] += 1
        # get the shot chance for the shot
        shot_chance = off_team.positions_dict[position].expected_stats['fg3']
    # pick a random number to determine if the shot is made
    random_shot = random.random()
    # case where the shot is made
    if random_shot < shot_chance:
        # add points to the player's stats
        off_possession_result[position][0] += shot_worth
        # keep track of makes
        if shot_worth == 2:
            off_possession_result[position][3] += 1
        else:
            off_possession_result[position][5] += 1
        # check if assist is made
        ast_chance = random.random()
        if ast_chance < 0.5:
            # pick a random player to get the assist
            assister = weighted_random_key(off_team.ast_distribution_pos)
            # if the assister is the same as the shooter, pick a new one
            while assister == random_player:
                assister = weighted_random_key(off_team.ast_distribution_pos)
            # add the assist to the player's stats
            off_possession_result[assister][2] += 1
        return off_possession_result, def_possession_result, next_team
    # case where the shot is missed
    # allow for chance of offensive rebound
    off_reb_chance = random.random() 
    # case where there is an offensive rebound
    # give a buff based on how good the team is at rebounding
    if off_reb_chance < 0.25 + 0.25*((off_team.expected_reb / def_team.expected_reb) - 1):
        # pick a random player to get the rebound
        random_player = weighted_random_key(off_team.reb_distribution_pos)
        # add the rebound to the player's stats
        off_possession_result[random_player][1] += 1
        # change who will have the ball on the next possession
        next_team = off_team
        return off_possession_result, def_possession_result, next_team
    # case where there is no offensive rebound
    random_player = weighted_random_key(def_team.reb_distribution_pos)
    # add the rebound to the player's stats
    off_possession_result[random_player][1] += 1
    return off_possession_result, def_possession_result, next_team
```

Deciding who gets to take the shot, get an assist, or get a rebound is done using the `weighted_random_key` function.  This function picks a random player according to the distribution described in the dictionaries of the `team` class.

```python
def weighted_random_key(prob_dict):
    '''
    Function to pick a random key from a dictionary of probabilities.
    '''
    # generate a random number
    rand_num = random.random()
    cumulative_probability = 0.0

    # iterate through the dictionary
    for key, probability in prob_dict.items():
        cumulative_probability += probability
        # check if the random number is less than the cumulative probability
        if rand_num < cumulative_probability:
            return key
```

Simulating a full game, then, simply requires us to simulate many possessions, and keep track of the players' stats along the way.

```python
class game:
    def __init__(self, team1, team2):
        self.team1 = team1
        self.team2 = team2

    def play_game(self):
        # initialize the box score for each team
        team1_box_score = {
            'PG': [0, 0, 0, 0, 0, 0, 0],
            'SG': [0, 0, 0, 0, 0, 0, 0],
            'SF': [0, 0, 0, 0, 0, 0, 0],
            'PF': [0, 0, 0, 0, 0, 0, 0],
            'C': [0, 0, 0, 0, 0, 0, 0]
        }
        team2_box_score = {
            'PG': [0, 0, 0, 0, 0, 0, 0],
            'SG': [0, 0, 0, 0, 0, 0, 0],
            'SF': [0, 0, 0, 0, 0, 0, 0],
            'PF': [0, 0, 0, 0, 0, 0, 0],
            'C': [0, 0, 0, 0, 0, 0, 0]
        }

        # compute number of possessions for each team: average of paces
        num_possessions = int(np.ceil(sum([self.team1.pace, self.team2.pace]) / 2.0))

        # initialize offensive and defensive teams
        off_team = self.team1
        def_team = self.team2
        for _ in range(num_possessions*2):
            off_result, def_result, next_team = possession(off_team, def_team)
            # add the results to the box score
            if off_team == self.team1:
                for position, stats in off_result.items():
                    for i in range(7):
                        team1_box_score[position][i] += stats[i]
                for position, stats in def_result.items():
                    for i in range(7):
                        team2_box_score[position][i] += stats[i]
            else:
                for position, stats in off_result.items():
                    for i in range(7):
                        team2_box_score[position][i] += stats[i]
                for position, stats in def_result.items():
                    for i in range(7):
                        team1_box_score[position][i] += stats[i]
            # switch the offensive and defensive teams
            off_team = next_team
            if off_team == self.team1:
                def_team = self.team2
            else:
                def_team = self.team1
        # sum the results for the team and add to the dictionaries
        team1_box_score['Team'] = [sum([stats[i] for stats in team1_box_score.values()]) for i in range(7)]
        team2_box_score['Team'] = [sum([stats[i] for stats in team2_box_score.values()]) for i in range(7)]
        return team1_box_score, team2_box_score
```

Simulating a season is also straightforward.  We enumerate all the matchups that will be played, initialize a DataFrame to store the stats for each game, and then simulate all the games.  We also keep track of the winners and losers of each game so that league standings can be recorded.

```python
class season:
    def __init__(self, num_teams):
        self.num_teams = num_teams
        self.num_games = 2*comb(self.num_teams, 2)
        
        # create list of teams
        self.teams = [team(name=team_nicknames[i], seed=i) for i in range(self.num_teams)]

        # create numpy array with all combinations of two teams
        self.matchups = np.array(list(combinations(self.teams, 2)))
        # redefine it with two of each matchup
        self.matchups = np.concatenate((self.matchups, np.flip(self.matchups, axis=1)))

        # initialize a pandas dataframe with game statistics by player
        self.df_game_stats = pd.DataFrame(columns= ['GAME_ID',
                                               'TEAM_NAME',
                                               'OPPONENT_NAME',
                                                'PLAYER_NAME',
                                                'POSITION',
                                                'PTS',
                                                'REB',
                                                'AST',
                                                'FG2M',
                                                'FG2A',
                                                'FG3M',
                                                'FG3A'
                                               ])
        
        # initialize dictionary of team records
        self.team_records = {key: [0, 0, 0] for key in team_nicknames[:self.num_teams]}

    def play_season(self):
        # play each game
        for i in range(self.num_games):
            # play the game
            team1, team2 = self.matchups[i]
            team1_stats, team2_stats = game(team1, team2).play_game()
            # initialize new rows of stats to add
            new_rows = []
            # add the stats to the game stats dataframe
            for key, value in team1_stats.items():
                new_rows.append([i, team1.name, team2.name, team1.name + '_' + key, key] + value)
            for key, value in team2_stats.items():
                new_rows.append([i, team2.name, team1.name, team2.name + '_' + key, key] + value)
            self.df_game_stats = pd.concat([self.df_game_stats, pd.DataFrame(new_rows, columns=self.df_game_stats.columns)], ignore_index=True)
            # update the team records
            if team1_stats['Team'][0] > team2_stats['Team'][0]:
                self.team_records[team1.name][0] += 1
                self.team_records[team2.name][1] += 1
            elif team1_stats['Team'][0] < team2_stats['Team'][0]:
                self.team_records[team1.name][1] += 1
                self.team_records[team2.name][0] += 1
            # case of a draw
            else:
                self.team_records[team1.name][2] += 1
                self.team_records[team2.name][2] += 1
        # sort the team records by wins
        self.team_records = {key: value for key, value in sorted(self.team_records.items(), key=lambda item: item[1][0], reverse=True)}
```

For a league with 30 teams, we can then simply run:

```python
s = season(30)
s.play_season()
```

The box score data is now ready for analysis.

## <ins>Data analysis using SQL</ins>

I used Amazon Web Services' RDS to host the database, and the free software DBeaver as the SQL client.  Uploading the data from the csv files and setting up the tables was straightforward using these.

As an example query, we can look for the instances where a player under 190.5 cm in height scored more than 30 points, and list those players by the number of times they achieved this feat.

```sql
WITH short_thirty_bombs AS
(
	SELECT g.player_id AS Player_ID, g.team_name AS Team_Name, g.pos_name AS Pos_Name, g.PTS AS Points
	FROM `game_stats`  AS g
	INNER JOIN `player_attributes` AS p 
	ON g.player_id = p.player_id
	WHERE g.PTS > 29.0 AND p.height < 190.5
)
SELECT COUNT(Player_ID) AS Num_Thirty_Bombs, Team_Name, Pos_Name
FROM short_thirty_bombs
GROUP BY Team_Name, pos_name 
ORDER BY Num_Thirty_Bombs DESC
```

The output from the query is:

```
6	Raccoons	pg
6	Cyclones	pg
5	Cobras	pg
4	Lions	pg
4	Dragons	pg
4	Knights	pg
4	Cheetahs	pg
3	Giants	pg
3	Tornadoes	pg
3	Wolves	sg
2	Zebras	pg
2	Panthers	sg
2	Bison	pg
2	Kangaroos	sg
2	Sharks	sg
2	Wildcats	sg
1	Aviators	pg
1	Panthers	pg
1	Falcons	pg
1	Tortoises	sg
1	Rhinos	pg
```

The Raccoons and Cyclones point guards were the leaders, with 6 instances each of scoring more than 30 points while being shorter than 190.5 cm.